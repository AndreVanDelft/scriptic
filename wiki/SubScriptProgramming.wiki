#summary Introduction to SubScript, the successor of Scriptic

= SubScript Programming =
==== André van Delft, October 2010 ====
== Introduction ==
Subscript is a new event-driven and parallel extension to the Scala programming language. It lets you specify many kinds of tasks very concisely and clearly:

  * Controllers for graphical user interfaces
  * Event handling
  * Event simulations
  * Parallelism: background processing and threading
  * Language processing: both parsing and producing texts

Subscript basically adds to Scala constructs from a mathematical theory named Algebra of Communicating Processes (ACP). Some spoons with syntactic sugar then make it very powerful. The resulting language constructs remind of features offered in several programming languages and techniques, such as:

  * Backus Naur Form, YACC and Java_CC
  * CSP and OCCAM
  * Linda

But SubScript also supports some real new programming idioms. This paper shows some examples. Maybe you will become enthusiastic about programming in SubScript after reading this document. The bad news is that the language is not implemented yet. The good news is that an efficient implementation is well possible. Essential features of SubScript that may seem too good to be true, are already working in an implemented predecessor language, Scriptic. This is available on Google Code. Subscript improves a lot over Scriptic:

  * cleaner base syntax
  * convenient syntactic sugar
  * more flexibility
  * simpler meaning  of process communication
  * more expressive power
  * precise language specification

The precise language specification is not yet ready. I am working on it, and only when a reasonable version is ready, an implementation will follow. For this implementation I could use some support. I have a busy job, so things don't proceed fast.

== Examples ==
=== Hello World ===
Most new programming languages are these days introduced by showing how to show the text “Hello World” on the console. In SubScript, you could fall back to the solution in the base language, Scala:
{{{
object HelloWorld {
  def main(args: Array[String]) {println("Hello, world!")}
}
}}}
This is exactly the standard HelloWorld program in Scala. It is a valid SubScript program as well, since SubScript is a quite clean extension to Scala. But this shows nothing specific about SubScript. A more telling alternative would be:
{{{
object HelloWorld {
 public scripts
  main(args: Array[String]) = {println(“Hello World”)}
}
}}}
The second line mentions so called "scripts". These are refinement constructs that Subscript adds as class members, next to the variables and methods that Scala offers. Typically, a script specifies dynamic behavior, but they may also be useful to manipulate data. A script definition mentions the name followed by an equals sign, and then a script body. In this case, HelloWorld has only one script, which acts in this case much like the Scala main method. Its script body contains a fragment of Scala code that calls println; curly braces enclose the code fragment. Such a code fragment is called an "action".

=== Hello World Variations ===
To show how sequences are specified in SubScript, we could split the printing of "Hello World" in two actions, so that they result in two output lines:
{{{
main(args: Array[String]) = {println(“Hello”)}; {println(“World”)}
}}}
The semicolon denotes sequence, just like in Java and Scala. There are quite some more similar operators, to denote choice, parallelism, interuption and other concepts. But as sequences are omnipresent, the semicolon is treated specially. In many cases it may be left out:
{{{
main(args: Array[String]) = {println(“Hello”)} {println(“World”)}
}}}
In Scala, a semicolon can be left out at the end of the line. SubScript was inspired by this, and goes beyond it by making all semicolons optional. Moreover, there is a close correspondence between sequences of processes, and multiplication in algebra. The algebraic symbol for multiplication is also usually omitted. However, a semicolon binds very weakly (as in Scala) whereas the "empty symbol" binds very strongly. Later we will see that this distinction allows to prevent lots of clumsy parentheses. 
Back to "Hello World". As another portion of syntactic sugar, the action braces around the call to println may be dropped:
{{{
main(args: Array[String]) = println(“Hello World”)
}}}
Yet another piece of syntactic sugar allows the parameter to follow the call after a comma:
{{{
main(args: Array[String]) = println, “Hello World”
}}}
It is possible to state that the "empty symbol" should be the comma rather than the semicolon. Just specify the comma after the equals sign:
{{{
main(args: Array[String]) =, println “Hello World”
}}}
When printing "Hello" and "World" again on two separate lines we could use the semicolon again:
{{{
main(args: Array[String]) =, println “Hello”; println “World”
}}}
And we can get rid of the semicolon there by appending it behind the comma. 
{{{
main(args: Array[String]) =,; 
                              println “Hello”
                              println “World”
}}}
The comma and the semicolon behind the equals sign denote that an "empty symbol" is a parameter separator in case it is not at the end of a line, or a sequence operator in case it is at the end of a line. For small script bodies it would not be very useful to get rid of operators this way, but the longer the script bodies, the more convenient it may be.
Now we see twice the word println. It could have been there even more times, in case the program would do more output. So the word println would be a good candidate for further simplification. Let's first create and use a script named _ (the underscore character) that calls println:
{{{
_(String s) = println,s&
main(args: Array[String]) =,; 
                              _ “Hello”
                              _ “World”
}}}
Scripts named are _ special "default" scripts: their names may be left out in the calls. Instead of {{{_(p1,p2)}}} and {{{_,p1,p2}}} we may simply write {{{p1,p2}}}.
So the Hello World could be written as:&
{{{
_(String s) = println,s
main(args: Array[String]) = “Hello” "World”
}}}
The nice thing that starts popping up here is that using some syntactic sugar, some scripts can specify data structures, and other scripts in another may determine what default operations would apply to simple data items. Then these scripts may be combined...

=== Data initializers ===
Scala comes with several simple example programs. One of these is about using data maps; it fills a certain map from color names to RGB values as follows:
{{{
val colors = Map(
  "red"       ->0xFF0000,
  "turquoise" -> 0x00FFFF,  
  "black"     -> 0x000000,
  "orange"    -> 0xFF8040,
  "brown"     -> 0x804000
 )
}}}
This is not a bad way, as compared to how it is typically done in Java. However, it is not the most convenient option. Often, data to be put in a map comes by copy+paste from a spreadsheet or a similar source. Then you have just rows and columns of cell values, which may or may not be separated by symbols like comma's. To use these as a map initializer would require the insertion of arrow symbols and comma's at the end of the line. In SubScript that would not be necessary: 
{{{
val colors = new SelfLoadingMap[String,Int] {
 scripts 
  _ = ,;
   "red"       0xFF0000
   "turquoise" 0x00FFFF
   "black"     0x000000
   "orange"    0xFF8040
   "brown"     0x804000
}
}}}
The first two lines here introduce some complexity, but for longer lists of data this approach would be useful, especially when you would copy these from sources such as spread sheets. 
SelfLoadingMap would typically be defined as follows: 
{{{
trait Data2[T,U] {
 scripts
  _(t:T,u:U)
  _
}
trait SelfLoadingMap[T,U] extends HashMap[T,U] with Data2[T,U] {
 scripts
  _(t:T,u:U) = {this+=(t->u)} 
 script_
}
}}}
Trait Data2 tells that their is a default script to process data pairs, and there is another parameterless default script. (For Scala newbies: a trait is, simply said, like an interface in Java, but it may contain complete method definitions. Traits almost support multiple inheritance.)
Trait SelfLoadingMap extends HashMap. It specifies that processing a data pair just adds it to itself as hash map. Moreover, the SelfLoadingMap has a body that calls its default script named _. Scala would not understand a mere underscore _ here, so that by convention it is written as script_. 
Note that the indentation is crucial here: script_ stands more to the left than the script defined in the previous line. Therefore it is not seen as start of a new script declaration, but as a start of the trait body. 
A similar rule holds for the interpretation of the line containing just "_" in trait Data2. It is just below the start of the previous script; in case it would have been more to the right, it would have been seen as part of the previous script body (although there was none). 
It is easy to use a data definition in multiple ways, by using Scala's near-multiple inheritance. E.g., suppose there was also a {{{trait InverseSelfLoadingMap[T,U]}}} that would create an inverse map, from "values" to "list of keys":
{{{
trait InverseSelfLoadingMap[T,U] extends HashMap[U,List[T]] with Data2[T,U] {
 scripts  
  _(t:T,u:U) = {+= (u->(t::( get(u) match {case Some(list)=>list
                                           case None      => Nil}
                   )   )   )
               }
 script_
}
}}}
We can now put some colors in a trait, including "darkness" as a synonym for "black": 
{{{
trait MyData extends Data2[String,Int] {
 scripts _ =,;
   "red"       0xFF0000
   "turquoise" 0x00FFFF
   "darkness"  0x000000
   "black"     0x000000
   "orange"    0xFF8040
   "brown"     0x804000
}
}}}
Then we could store these data in either the hash map or the inverse hash map using
{{{
object        MapWithMyData extends        SelfLoadingMap[String,Int] with MyData
object InverseMapWithMyData extends InverseSelfLoadingMap[String,Int] with MyData
}}}
Printing using 
{{{
println ("MapWithMyData: "+MapWithMyData) 
println ("InverseMapWithMyData: "+InverseMapWithMyData)
}}}
results essentially in:
{{{
MapWithMyData: Map( 
  turquoise -> 65535, 
  red   -> 16711680,  
  orange  -> 16744512,  
  brown   -> 8404992,  
  darkness  -> 0,  
  black   -> 0)

InverseMapWithMyData: Map( 
     65535  -> List(turquoise),  
  16711680  -> List(red),  
  16744512  -> List(orange),  
   8404992  -> List(brown),  
         0  -> List(darkness, black))
}}}
===Text manipulation===
Scala lets you conveniently mix XML stuff with normal program elements, which is for instance useful for generating web content. The Scala site contains an illustrative Addressbook sample 
  [http://www.scala-lang.org/node/45 http://www.scala-lang.org/node/45]
A typical class in that example is: 
{{{
  class AddressBook(a: Person*) {
    private val people: List[Person] = a.toList

    /** Serialize to XHTML. Scala supports XML literals
     *  which may contain Scala expressions between braces,
     *  which are replaced by their evaluation
     */
    def toXHTML =
      <table cellpadding="2" cellspacing="0">
        <tr>
          <th>Name</th>
          <th>Age</th>
        </tr>
        { for (val p <- people) yield
            <tr>
              <td> { p.name } </td>
              <td> { p.age.toString() } </td>
            </tr> 
        }
      </table>;
  }
}}}
In SubScript you could write instead of toXHTML:
{{{
    scripts 
      tableXHTML  =,;
""""
<table cellpadding="2" cellspacing="0">
  <tr>
    <th>Name</th>
    <th>Age</th>
  </tr>
""""
( for (val p <- people)
""""
  <tr>
    <td>"""" p.name """"</td>
    <td>"""" p.age.toString() """"</td>
  </tr>
""""
) 
"</table>"
     _(s1:String) = print(s1)       
     _(s1:String,s2:String) = print(s1,s2)       
     _(s1:String,s2:String,s3:String) = print(s1,s2,s3)
}}}

At the center there is a for loop construct. Note that the for construct occurs inside the parenthesized loop expression, rather than before that. 
tableXHTML does not very different over the former pure Scala version, and it not really an improvement: the specification is a few lines longer, and the result is just a string, rather a more structured piece of XML. However, such SubScript code not only applies to creating XML strings, but as well all to creating other kinds of text. 

The above code could be improved using some special definitions for XML tags:
{{{
  class XMLTag {
    def start = "<"+getClass.getName+">"
    def end  = "</"+getClass.getName+">"
  }
  case class tr extends XMLTag
  case class th extends XMLTag
}}}
With scripts that print table headers, rows and cells the alternative for toXHTML would become:
{{{
  scripts
    tableHeader(s1:String, s2:String) 
    = """<table cellpadding="2" cellspacing="0">"""
      tableRow,s1,s2

    tableRow(s1:String, s2:String)
    = tr.start tableCell,s1 tableCell,s2 tr.end

    tableCell(s:String) = th.start s th.end

    tableXHTML = tableHeader,"Name","Age";
                 for (val p<-people) tableCell,p.name 
                                     tableCell,p.age.toString();
                 tableFooter
}}}
Subscript also eases parsing text. For instance, the following code could parse the just generated XML text from an input source:
{{{
  scripts
    tableHeader(s1:String??, s2:String??) 
    = anyText tableRow,s1?,s2?

    tableRow(s1:String??, s2:String??)
    = tr.start tableCell,s1? tableCell,s2? tr.end

    tableCell(s:String??) = th.start s? th.end

    tableXHTML = tableHeader,"Name","Age";
                    .. 
                    tableRow, name:String?,age:String?
                    {people.add(Person(name,Int.parse(age))};
                 tableFooter

     anyText  = scanAny
     _(s1:String??) = scan(s?)
}}}       
Here the script scan(s:String??) would stand for scanning a string. What string? It could be any string, to be yielded in the formal output parameter s. The first question mark appending the parameter declaration denotes that it is an output parameter; the second question mark denotes that this parameter may also be used with a forcing value. 
That forcing happens a few lines higher, with th.start This reduces to {{{_(th.start)}}}. Here the actual parameter does not have a question mark, whereas the formal parameter has two question marks; therefore the parameter th.start is regarded as a forcing value. The idea of this forcing is that the deeper call to scan will only succeed if the input matches this paramter value.

{{{_(s1:String??)}}} calls {{{(s?)}}} with 1 question mark. Normally this single question mark in a call denotes an output parameter, but since the actual parameter is itself a formal parameter that might be forcing, the parameter to scan scan will adapt itself to be forcing in such a case.
So the table cell, defined as th.start s? th.end, will "happen" when the following text is scanned: first {{{<th>}}}, then a quite arbitrary string, and then {{{</th>}}}.

The actual output parameters name:String?,age:String? are at the same time variable declarations.

Just as in the previous example, tableXHTML contains a loop; this time not with a for-iterator, but with an ellipis symbol (..). Thiis symbol denotes a loop, but at the same time an optional exit point. The loop will exit in this case when tableFooter happens instead of tableRow.


=== The Sieve of Erasthostenes ===
New programming languagues are these days often benchmarked by shouwing how they allow for the specification of the Sieve of Erasthostenes. This is about an algorithm to compute prime numbers, thousands of years ago invented by the Greek Erasthostenes. Informally, the algorithm starts with the first prime number, 2.  From the natural numbers, up to a maximum value for practical reasons, it wipes out all multiples of this prime. The next remaining number in the list, 3 must then also be prime. Now all multiples of 3 are erased. This way prime numbers are discovered one by one, and each acts as a sieve to find more primes.
It is fun to program this using sieves as processes that run in parallel, at least conceptually.  SubScript allows for a very short specification, in only 10 lines of code:
{{{
object Erasthostenes { 
  public scripts
   main(args: Array[String]) = generator(2, 1000000) 
                                 ==> (..==>sieve) ==> printer
   generator(start,end:Int)  = for(i<-start to end) <=i
   printer                   = ..=>i:Int? println,i
   sieve                     = =>p:Int? @here.parentPipe:<=p;   
                             ..=>i:Int?      if (i%p!=0) <=i
   <==>i:Int                 = η
}
}}}
The main script specifies 3 parallel processes that are configured in a pipeline:  
{{{
main = generator(2, 1000000) ==> (..==>sieve) ==> printer
}}}
A generator process generates numbers from 2 to 10000000. It is connected using the pipe symbol ==> to a process that is specified by (..==>sieve). The pair of dots, also called small ellipsis, here specifies an iteration that proceeds with new loop passes "when they would become needed". 
In this case the iteration is not sequential (as usually seen), but the pipe symbol specifies that the iteration builds an ever growing pipe. This iteration starts by creating a first pipe element called sieve. As soon as this pipe element starts doing something (by accepting a number from the left hand side),  the next pipe element is created etc. Each pipe element will act as a sieve for a recognized prime number. Prime numbers that pass through all sieves are sent through the pipeline to the printer process.
The generator is a script with two parameters that indicate in what range numbers must be generated. Internally it contains a sequential loop using a for iterator that has been inherited from Scala:
{{{
  generator(start,end:Int)  = for(i<-start to end) <=i
}}}
The loop states that each pass the loop variable i is sent over the pipe, using <=i. This sending is synchronous: completion waits until the variable has been received at the other side. This ensures that the loop does not explode.

The next script defines the printer:
{{{
   printer = ..=>i:Int? println,i
}}}
Here again the two dots (small ellipsis) denote two things that are in principle more or less independent: a loop, and an optional break point. The effect of starting a sequence with this symbol causes it to happen zero or more times. It would have been one or more times when the dots had appeared at the end of the sequence instead, as in =>i:Int? println,i..
In the sequence, the printer waits for an number to arrive over the pipe, using the phrase: =>i:Int? This does two things in one statement: it declares a variable i of type Int, and it waits on the pipe to receive the value. This is syntactic sugar for the following sequence:
{{{
var i:Int =>i?
}}}
This would be longer to write, and it repeats the i, which is error prone redundancy. I would recommend the shorter way of writing.
Then the printer prints the number using a call to the method println.
The next script specifies the behaviour of a single sieve process:
{{{
   sieve = =>p:Int? @here.parentPipe:<=p;   
         ..=>i:Int?      if (i%p!=0) <=i
}}}
Note the semicolon at the end of the first line. The semicolon is optional, but when you leave it out, you get an operator that binds very strong, whereas the semicolon binds very weak. This way, the sequence of the first line is separated from the sequence of the second line. The second line denotes a loop of its own; whereas the first line does not. We could equivalently have written the specification with parentheses instead of the semicolon, 
{{{
   sieve = (=>p:Int? @here.parentPipe:<=p)
         (..=>i:Int?      if (i%p!=0) <=i)
}}}
This takes 3 more characters to type and to read. I think it is often better to go for the shorter option in such cases.
The sieve starts by accepting its own prime number named p from the pipe. Shortly after this action happens, the magic iteration (..==>sieve) in the main script activates the next sieve. Thereafter the "current" sieve (the one that just had accepted its prime number) must first send its prime on to the printer Just sending it over the pipe to the right would be wrong, because there the next sieve is listening. The sieve specifies that the sending has to go one pipe level up, using
{{{
@here.parentPipe:<=p
}}}
The code between @ and : is activation code, i.e. Scala code that is executed when this part becomes active. here in a script is a special pseudo variable that refers to where the script "currently is". Think of the execution of a SubScript program as the construction, maintenance and tear down of a "call graph", which is a more general structure than a "call stack" that is known from more conventional programming languages. Once activated, the operators and operands in scripts become nodes in the call graph. The graph is not simply a tree, because branches may grow together by performing communication, like sending and receiving data over a pipe. here denotes the "current node" In the call graph. It is similar to the this pseudo variable this in classes. The method call here.parentPipe makes sure that the send action  <=p will be one pipe level up.
Then, thanks to the semicolon, the sieve enters a loop:
{{{
 ..=>i:Int? if (i%p!=0) <=i
}}}
Every once in a while it receives a number from the pipe. Then it checks whether its prime is a divisor of this number; if not, the number could be prime, and it is send onward to the next sieve.
The last script defines that integer numbers may be communicated over any pipe within the current object.
{{{
   <==>i:Int = η
}}}
The "contents" of such a communication could have been an action with some Scala code between braces, such as {println "<==>"+i}
When nothing should be done, except for the conceptual action that happens, we could have provided an empty pair of braces: {}. Now the Algebra of Communicating Processes comes in with its symbolism. ACP symbolizes an "empty action" with the Greek `eta symbol: η. I recommend to use this symbol and similar ones from ACP whenever applicable. It reminds you and the readers of the program of the gentle fact that mathematics is here at work.

References to the Sieve of Erasthostenes in other languages:

 C: [http://primes.utm.edu/links/programs/sieves/Eratosthenes/C_source_code/ ]
 Java: [http://primes.utm.edu/links/programs/sieves/Eratosthenes/Java_source/]
 Go: [http://blog.onideas.ws/eratosthenes.go]
 F#: [http://fsharpnews.blogspot.com/2010/02/sieve-of-eratosthenes.html]
 Maisie: [http://pcl.cs.ucla.edu/projects/maisie/tutorial/programming/]
 C#,LINQ: [http://www.codethinked.com/post/2010/01/12/The-TekPub-LINQ-Challenge-And-The-Sieve-Of-Eratosthenes.aspx]


=== A Simple GUI Application ===
Suppose we need a simple program to look up items in a database, based on a search string.[[Image:hiMWm_d_Fo4XGKCyxLQ3-1RXoI7AH19m65B_QUVpzxyXd8vtf3VNtBZBFbHmx4GuhPm7lyNwrVoscS_1cn6bPxM03RJ7kQNnYLmtJTZlzidq57eVFA]]The user can enter a search string in the text field and then press the Go button. This will at first put a “Searching…” message in the text area at the lower part. Then the actual search will be performed at a database, which may take a few seconds. Finally the results from the database are shown in the text area.In SubScript you can program that sequence of events and actions in an intuitively clear way:

searchSequence <nowiki>=</nowiki> searchCommand  showSearchingText    searchInDatabase showSearchResults

Here searchCommand would represent the event of the user pressing the button. showSearchingText and showSearchResults each write something in the text area. searchInDatabase does the database search.searchCommand is refined with a reusable script action:

searchCommand  <nowiki>=</nowiki> action(searchButton)

This action script "happens" when the user presses the button. It is (or: will be) defined in a trait called Swing. As a bonus, the action script makes sure the button is exactly enabled when applicable. It will automatically be disabled as long as searchInDatabase is going on.A trait that descends from the trait Swing is named Swing_. It adds some default scripts named _ that simply call other scripts, e.g.,

_(JButton b) <nowiki>=</nowiki> action(b)

So by using the trait Swing_ we may define searchCommand as

searchCommand  <nowiki>=</nowiki> _(searchButton)

or, because of the magic syntactic sugar:

searchCommand  <nowiki>=</nowiki> searchButton

This states as concise as possible that clicking the search button triggers he search.The script calls showSearchingText and showSearchResults set the text contents of the text area named outputTA. A complication is that this must happen in the swing thread:

showSearchingText <nowiki>=</nowiki> @swing: {outputTA.text = ...}showSearchResults <nowiki>=</nowiki> @swing: {outputTA.text = ...}

Here @swing: is again ''activation code'': swing is a method in the Swing trait, that has the special value here as a parameter. This activation code makes sure that its operand (the code fragment) is executed in the swing thread, just as needed.The searchInDatabase could in a similar way perform a search on the database in a background thread. Or the search could be simulated by a short sleep. A nicer looking way to specify that an action must happen in a background thread is by enclosing it in braces with asterisks:

searchInDatabase  <nowiki>=</nowiki> {* Thread.sleep 3000 <nowiki>*}</nowiki>

If you would to program this functionality in plain Java, the resulting code will be much more complex. Even without enabling and disabling the button, the code would look like:

private void searchButton_actionPerformed() {

 outputTA.text = "Searching for: " + searchTF.text;

 new Thread() {

   public void run() {

 Thread.sleep(3000) //i.e. searchInDatabase

 SwingUtilities.invokeLater(

   new Runnable() {

     public void run() {

   outputTA.text = "...";

     }

   }

 );

   }

 }.start();

}

In Scala it would be a bit less bad, though

private void searchButton_actionPerformed() {

 outputTA.text = "Searching for: " + searchTF.text;

 new Thread() {

   public void run() {

 Thread.sleep(3000) //i.e. searchInDatabase

 Swing.onEDT {outputTA.text = "...";}

   }

 }.start();

}


'''Extending the program'''

It is easy to extend the functionality of this program. For instance, the search action may also be triggered by the user pressing the Enter key in the search text field (searchTF). For this purpose we can adapt the searchCommand. Another user command could be to cancel an ongoing search in the database. For this the user could press a Cancel button, or press the Escape key. Finally the user may want to exit the application by pressing an Exit button, rather than clicking in the closing box. Moreover, he should then be presented a dialog where he can confirm the exit.[[Image:EA_gcfE2dbSZwbTIn4oxhRKPKkqwQ5SB4rKF6zs3OOzMeXvR0B05ByPPplsoGlKoQVIGq1EqFiLTaiaY2J8ScEqc6h9d0no15jrnyLXxy3A8LZZSeg]]

searchCommand <nowiki>= </nowiki>searchButton + KeyEvent.VK_ENTER , searchTFcancelCommand <nowiki>= </nowiki>cancelButton + KeyEvent.VK_ESCAPE, searchTF exitCommand <nowiki>= </nowiki>exitButton   + windowClosing

Here the plus symbol denotes choice, just like the semicolon denotes sequence. There are 7 other operators like these, most of which express a specific flavour of parallelism.windowClosing is a predefined script.KeyEvent.VK_ENTER is a character code; together with the comma and searchTF it is shorthand for

_(KeyEvent.VK_ENTER, searchTF)

And let's assume now that in the trait Swing_ the default script on characters and a component is

_(char c, JComponent comp) <nowiki>=</nowiki> key(c, comp)

So this would react to the given key being pressed in the given GUI component. If we ignore the searchTF parameter, we see that searchCommand has been defined as an addition of a button and a character. This is something new in programming; I call it ''Item Algebra'', see later.After the exit command, a confirmation dialog should come up, in the Swing thread. If the user confirms, then the program should end. After the cancel command, an applicable text should be shown in the text area:

exit  <nowiki>=</nowiki>   exitCommand @swing: while(!confirmExit())cancelSearch  <nowiki>=</nowiki> cancelCommand @swing: {showCanceledText()}

This exit script is easily added to the live script:

live  <nowiki>=</nowiki> searchSequences || exitsearchSequences <nowiki>=</nowiki> ...searchSequence

The double bar || denotes or-parallelism: both operands happen, but when one operand terminates successfully the parallel composition also terminates successfully. The double bar is here analogous to its usage in boolean expressions. The same holds for 3 other parallel operators: &&, |and &.The 3 dots (...) are equivalent to while(true). Two dots (..) would create a loop with an optional exit, a bit comparable to the asterisk in regular expressions.To fit in a call to the cancelSearch script, we have to split up the script searchSequence:

searchSequence <nowiki>=</nowiki> searchCommand<nowiki>;</nowiki> searchAction / cancelSearchsearchAction   <nowiki>=</nowiki> showSearchingText searchInDatabase    showSearchResults

This way the Cancel button will only become enabled after the search command has been issued, and it will be disabled again after the search results have been shown.The slash symbol (/) denotes breaking behavior: the left hand side happens, but the right hand side may take over. The semicolon should not be left out here, because an "empty symbol" would bind too strong.

=== Discrete Event Simulation ===
== Background ==
SubScript has been inspired by an theory called the Algebra of Communicating Processes. The next overview of that theory has largely and shamelessly been copied from Wikipedia - no need to reinvent the wheel.[http://en.wikipedia.org/wiki/Algebra_of_Communicating_Processes http://en.wikipedia.org/wiki/Algebra_of_Communicating_Processes]However, there are numerous differences between the theory and the programming language. These are all presented with their motivation.

=== Algebra of Communicating Processes ===
<nowiki>The Algebra of Communicating Processes (ACP)[2] is an algebraic approach to reasoning about concurrent systems. It is a member of the family of mathematical theories of concurrency known as process algebras or process calculi[1]. More so than the other seminal process calculi (CCS and CSP), the development of ACP focused on the algebra of processes, and sought to create an abstract, generalized axiomatic system for processes and in fact the term process algebra was coined during the research that led to ACP.</nowiki>ACP uses instantaneous, atomic actions (a,b,c,...) as its main primitives. Two special primitives are the deadlock process d and the empty process e.The primitives may be combined to form processes using a variety of operators. These operators can be roughly categorized as providing a basic process algebra, concurrency, and communication:

* Choice and sequencing — the most fundamental of algebraic operators are the alternative operator ( + ), which provides a choice between actions, and the sequencing operator ( · ), which specifies an ordering on actions. So, for example, the process (a+b)·c first chooses to perform either a or b, and then performs action c. How the choice between a and b is made does not matter and is left unspecified. Note that alternative composition is commutative but sequential composition is not (because time flows forward).

* Concurrency — to allow the description of concurrency, ACP provides a merge operator, ¦. This represents the parallel composition of two processes, the individual actions of which are interleaved. As an example, the process (a·b)·(c·d) may perform the actions a,b,c,d in any of the sequences abcd,acbd,acdb,cabd,cadb,cdab.

* Communication — pairs of atomic actions may be defined as communicating actions; they can then not be performed on their own, but only together, when active in two parallel processes. This way, the two processes synchronize, and they may exchange data.

ACP fundamentally adopts an axiomatic, algebraic approach to the formal definition of its various operators. Using the alternative and sequential composition operators, ACP defines a basic process algebra which satisfies the following axioms:x+y  = y+x     (x+y)+z = x+(y+z)   x+x  = x   (x+y)·z = x·z + y·z   (x;y)·z = x·(y·z)   The special primitives d and e behave much like the 0 and 1 that are neutral elements for addition and multiplication in usual algebra:d+x   = x     d·x   = d     e·x   = x     x·e   = x     There is no axiom for x·d. It just means: x and then deadlock.x+e means: optionally x. This is illustrated by rewriting(x+e)·y using the given axioms:(x+e)·y  =  x·y +e·y  =  x·y + yThe merge operator ¦ is defined in terms of the alternative and sequential composition operators. This definition requires a auxiliary operator named left-merge, with symbol +. x+y means that x starts with an action, and then the rest of x is done in parallel with y. Another operator is the communication-merge, with symbol |.x|y means that x and y start with a communication (as a pair of atomic actions), and then the rest of x is done in parallel with the rest of y.The axioms defining the merge are:x¦y   =  x+y + y+x + x|ya·x+y   =  a·(x¦y)a+y   =  a·y(x+y)+z = x¦z + y¦za·x|b   =  (a|b)·xa|b·x   =  (a|b)·xa·x|b·y =  (a|b)·(x¦y)(x+y)|z = x|z + y|zx|(y+z) = x|y + x|zAnother, often simpler, way to define the operators is by means of a technique called Structural Operational Semantics; see the appendix.Many extensions to ACP have been developed, e.g. interrupt and disrupt operators, and notions of time and priorities. Like the merge operator, additional operators were always basicly defined in terms of sequence, choice and communication.Since its inception in 1982, ACP has successfully been applied to the specification and verification of among others, communication protocols, traffic systems and manufacturing plants.

=== Item Algebra ===
Some previous SubScript examples presented algebraic expressions on items that were not directly processes:cancelCommand <nowiki>= </nowiki>cancelButton + escapeKey<nowiki>main(args: Array[String]) = "Hello" "World"</nowiki>_ =,;   "red"   0xFF0000   "turquoise" 0x00FFFF   "darkness"  0x000000   "black"   0x000000   "orange"  0xFF8040   "brown"   0x804000These items were converted into processes using default scripts, which could as a start be abstract. Now what is for instance the addition of a button and a key? It is just a choice. It is not yet decided what the choice is used for. It could be made operational so that it becomes an input description for a GUI program, as done using the default scripts in the earlier example. However, it could also be made operational as an instruction for an operator who is testing that GUI program, listing the possible actions to try.We may easily modify ACP a little so that it becomes an Item Algebra: next to the action atoms a,b,c,...allow for item atoms i,j,k, .... Then note that there are no axioms for the merge operators with i,j,k. So merges concerning item atoms cannot be rewritten in terms of sequence and choice.It is possible to turn an Item Algebra specification into a Process Algebra specification: just add definitions for the item atoms (that are then no atoms any more) so that these i,j,k, ... are defined in terms of action atoms a,b,c,... . This would be an operationalisation of the Item Algebra specification.In the earlier SubScript example script, the phrase "red" 0xFF0000 would neither denote a sequence or choice, but a tuple: it will act as a pair of parameters for a default script. So we could say that in an Item Algebra specification, tuples of the form (i,j) would be allowed. To operationalize, definitions should be added for such tuples in terms of atomic actions.

==== Example ====
You may consider formal syntax definitions of programming languages as a kind of Item Algebra specifications. A particular instance will be presented later: the SubScript syntax that is specified using SubScript itself. A simplified preview is:scriptDefinition    = scriptHeader "=" scriptExpressionscriptHeader  = scriptName optionalParameters scriptName    = identifier + "_"optionalParameters    = . "(" formalParameters ")"formalParameters    = .; formalParameter .. ","formalParameter     = identifier ":" type . formalOutputMarkerformalOutputMarker    = "?" + "??"Here type and scriptExpression have not been worked out. The period "." is an optional exit; the difference with the ellipsis ".." is that it does not denote a loop.

=== From ACP and Scala to SubScript ===
SubScript extends Scala with scripts, which are inspired on ACP. There are many small and big differences between ACP and SubScript; yet the algebraic theory was a major inspiration for the programming language.

==== Lexical differences ====
ACP specifications apply quite some mathematical symbols. For a programming language, it is in principle desirable that all characters are easy accessible on the keyboard. On the other hand it would as well be nice if SubScript would have some mathematical look and feel. That is helped by using symbols like d and e for deadlock and an empty process. In fact there are three similar processes: "?"  "?"  "t" . For these symbols are not easy to type, programmers may create their own definitions with plain names such asdeadlockProcess  = demptyProcess   = ehiddenProcess  = ?neutralProcess   = ?tauProcess   = tACP symbols for choice, sequence parallelism are "+", "·" and  "?". The latter two are again hard to type, so SubScript applies more accessible symbols ";" and  "&". However, as a courtesy to the ACP scientists, their symbols are valid too in SubScript. Just like in ACP the sequence operator may be left out, so that there are even three ways to denote sequences.& vs ¦The operator precedences follow Scala rules, except for the strongly binding "·" and  "?".

==== Native language interoperability ====
SubScript scripts are class members, next to variables and methods. From regular Scala code, one may call a script, provided that it has no formal output parameter. The script will return a boolean result, indicating success or failure. Failure occurs when in ACP terms the script ends essentially as the deadlock process d.Scala program execution normally starts at a function <nowiki>main(args: Array[String])</nowiki>Instead such a function one may provide a script with the same parameter.Scripts may contain operands that in turn contain Scala code:- code fragments that are enclosed in brace pairs such as { … }. There are several flavours. One kind of code fragments execute in a separate thead. Other kinds act as event handlers.- method calls; these appear just like they would in Scala- script calls: the actual parameters are Scala expressions- constructs if, while, for and matches contain Scala expressionsExtra&changed: operators, neutral element, iterations, if, matchCommunication: scripts, 1 or more partners, unbound, binding, channels, pipesSyntactic sugarStatic template treesCall GraphCall Graph Nodes: template, state, links, propertiesProgram execution: activate, deactivate, suspend, resume, succeed, action start, action end, exclusionActivation&deactivation code, Axioms only valid at a high level of abstractionCode executors, execution managersCharacterization of operators and operands

== Language Reference ==